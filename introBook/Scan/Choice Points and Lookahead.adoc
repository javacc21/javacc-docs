:imagesdir: ../images
// From Wiki titled "Choice Points and Lookahead"
=== Choice Points and Lookahead

(((Choice Points)))
A *choice point* in a JavaCC grammar is a juncture where the parser must decide between two or more expansions. There are four kinds of choice point:

* An optional expansion, i.e. the expansion inside a zero or one construct, which is written ( Foo )? or alternatively as [ Foo ]
* A repeated expansion that is possibly empty, a.k.a. zero or more which is written as ( Foo )*
* A repeated expansion that cannot be empty, a.k.a. one or more which is written as ( Foo )+
* The expansions within a choice construct, i.e. n (two or more) expansions, separated by the “|” character, i.e. Foo | Bar | Baz

(Perhaps needless to say, all of these constructs arbitrarily combine and nest within one another to an arbitrary level of complexity.)

I think the simplest way to think about the above cases (for most people, anyway) is just in terms of their analogues in a procedural programming language. The first three cases are effectively binary choices, a choice between entering the expansion inside the parentheses and jumping directly to what follows it. In all of these cases, the expansion within the parentheses is a choice point. The last case is a choice between n options and each of those n sub-expansions is a choice point in the grammar.

==== Zero Or One Expansion

(((Choice Points, Java Code Equivalents)))
A _zero-or-one_ is a single (non-looping) choice. If the enclosed expansion matches, we enter it, and if not, we jump directly to whatever follows it. So, if we write:
----
( inner_expansion )? following_expansion
----

This is quite analogous to a simple if statement in a procedural language. In pseudo-code, something like:
----
if (inner_expansion_matches()) do inner_expansion();
following_expansion();
----

==== Zero Or More Expansion

A _zero or more_ is basically the same as a _zero or one_ except that it is not a one-time choice, but a loop. So, the following:
----
( inner_expansion )* following_expansion
----

is a loop that, on each iteration, chooses between the inner_expansion and the following_expansion. As long as it chooses the first one, it stays in the loop, but once it opts for the following_expansion, it breaks out. In pseudo-code, that looks like:
----
while (inner_expansion_matches()) do inner_expansion();
following_expansion();
----

==== One or More Expansion

A _one or more_ is like a _zero or more_ loop except that the first iteration is obligatory. Thus:
----
( loop_expansion)+ following_expansion
----

can be considered as just a more terse way of writing:
----
loop_expansion ( loop_expansion )* following_expansion
----

So, one should bear in mind that a _one or more_ loop is a little bit tricky because, on the first iteration, it is *not* actually a _choice point!_ But, then again, the difference between _zero or more_ and _one or more_ is exactly the same as the difference between a while loop and a do-while loop in Java or similar languages. So, in pseudo-code, the one or more would be:
----
do {inner_expansion();} while (inner_expansion_matches());
following_expansion();
----

which, again, is just an abbreviated way of writing:
----
inner_expansion();
while (inner_expansion_matches()) inner_expansion();
following_expansion();
----

So, again, we see that the first iteration is actually executed unconditionally.

==== The Choice Construct

This construct, something like expansion1 | expansion2 | ...expansionN | ...final_expansion might as well be thought of as an if-elseif-else construct. Again, in pseudo-code:
----
if (expansion1matches()) 
   expansion1(); 
else if (expansion2matches())
   expansion2();
    ....
else
   final_expansion();
----

We test the conditions in sequence until one is satisfied and then we enter that expansion and that's that.

Well, all the above kind of begs the question of how we decide when an expansion matches the current input.

In the default case, this has a very simple answer:

==== The Default Choice Resolution Algorithm

(((Choice Points, JavaCC Default is LL(1))))
The _default_ choice resolution algorithm for whether we enter an expansion at a choice point is just to check ahead _exactly one_ token and if that token potentially starts the expansion, then that is what we choose!

Another way of expressing this is that _the default assumption of a parser generated by JavaCC is that the grammar is LL(1)._

NOTE: I use this sort of terminology to demystify things. There is no need to be intimidated by this sort of thing. The above is just a fancy way of saying that looking ahead one token is enough to resolve any choices at any juncture in the grammar.

Now, to be clear, looking ahead one token might be sufficient or not in any given spot, but if we don't specify any extra information, that is the _default assumption_. Another fancy, theoretical way of expressing this default would be:

_We enter an expansion at a choice point if the next token is in that expansion's first set._  (See the section on Expansion's First Set in Chapter 3 for more information on first sets.)

Again, no need to be intimidated by the lingo. An expansion's first set is simply the set of tokens with which an expansion can begin. Depending how your brain is wired, it might be easier to think about it the other way round. Like so:

_If the next token is not in an expansion's first set, the expansion cannot possibly be matched, so we skip ahead to the following choice._

(((Choice Points, First Match is Chosen)))
Now, regardless, it may be the case that more than one of the expansions at a given choice point matches this condition. Well, in that case, we have a secondary rule: _the first one gets it_. And this is really no different, by the way, from how if-elseif-else in a procedural programming language works.

If you write:
----
 if (x > 0) doSomething();
 else if (x > 1) doSomethingElse();
 else somethingElseEntirely();
----

then clearly the second choice, doSomethingElse() is never entered, because if the condition x > 1 is satisfied, then x > 0 would also have been satisfied, so we would have already entered doSomething() and subsequently jumped out of the if-else construct! Or, another way of putting this is that if x is 2, say, the first and second conditions match, but the first one gets it!

A funny thing about all this is that, in the context of procedural programming languages, nobody considers this to be a big deal or to be confusing. However, the legacy JavaCC tool does make a big deal out of this, always emitting annoying warnings in analogous situations. 

JavaCC 21 does not emit warnings about unreachable code at this time. At some later point, some checks may be put in place to emit unreachable code warnings since that could be helpful in a few cases but it is not a high priority. This was actually quite annoying in legacy JavaCC, because most of the time, the warnings emitted were complete spurious!

In any case, let's move to a concrete example. Suppose we have a choice construct like:
----
 "foo" "bar" ...
 |
 "foo" "baz" ...
 |
 "bar" "bat" ...
----

then yes, the second choice is clearly unreachable. Given that our default choice resolution algorithm is to look ahead exactly one token, if the next token is “foo”, we always enter the first choice and never the second one.

So, this leads us naturally to the next question, which is:

_If the default resolution algorithm is not sufficient, (LL(1) is insufficient) how do we override that default and get the behavior we actually want?_

The answer is that we do this by defining some sort of modified _lookahead_ statement that overrides the default resolution algorithm. Probably the term _predicate_ is more accurate, although _condition_ might be better as it is a more familiar term. But I will frequently use the term _lookahead_  because resolving the choice very often does involve scanning ahead more than one token.

===== Newer Dispositions in JavaCC 21

JavaCC 21 has worked to improve the lookahead tools by adding: 

*  The SCAN command, with improved capabilities over legacy LOOKAHEAD
*  Streamlined SCAN syntax to express the lookahead conditions more tersely
*  Up-To-Here marker and Up-To-Here-Plus marker to remove excessive repetitiveness in defining lookahead conditions
*  Syntactical LOOKAHEAD's now work correctly when nested
*  Semantic LOOKAHEAD's work as expected but have been made much less important by the addition of Contextual Predicates (see the section on Contextual Predicates in Chapter 2 for more information)

The following sections in this chapter will cover the above points in more details.
